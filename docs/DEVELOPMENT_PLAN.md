# План разработки SSH Tunnel System

## Общая информация проекта

**Цель:** Создать собственный аналог Serveo для доступа к серверам за NAT через SSH туннели
**Стек:** Go (надежность + простота деплоя)
**Инфраструктура:** 
- Мостовой сервер с белым IP и собственным доменом
- Несколько удаленных серверов за NAT (1500 км от базы)

## Этап 1: Подготовка инфраструктуры

### 1.1 Настройка GitHub репозитория
- [x] Создать репозиторий `ssh-tunnel-system`
- [x] Настроить структуру проекта
- [x] Создать README с описанием
- [ ] Настроить GitHub Actions для CI/CD

### 1.2 Структура проекта
```
ssh-tunnel-system/
├── cmd/
│   ├── tunnel-server/    # Мостовой сервер
│   ├── tunnel-client/    # Клиент для серверов за NAT
│   └── tunnel-cli/       # CLI для управления
├── pkg/
│   ├── tunnel/          # Логика туннелирования
│   ├── auth/            # Авторизация и безопасность
│   ├── config/          # Конфигурация
│   ├── monitor/         # Мониторинг соединений
│   └── api/             # gRPC API для CLI
├── deploy/              # Docker, systemd сервисы
├── configs/             # Примеры конфигураций
└── docs/                # Документация
```

### 1.3 Настройка домена
- [ ] Настроить DNS записи:
  - `tunnel.yourdomain.com` → IP мостового сервера

## Этап 2: Разработка мостового сервера

### 2.1 SSH Tunnel Server (cmd/tunnel-server)
- [ ] Создать SSH сервер для приема reverse connections
- [ ] Реализовать маршрутизацию туннелей
- [ ] Добавить систему регистрации клиентов
- [ ] Настроить проброс портов SSH (22 → динамические порты)
- [ ] Реализовать HTTP proxy для веб-сервисов

### 2.2 Система авторизации (pkg/auth)
- [ ] Генерация и управление SSH ключами
- [ ] Токены доступа для клиентов
- [ ] Whitelist серверов по MAC/hostname
- [ ] Логирование подключений

### 2.3 gRPC API сервер (pkg/api)
- [ ] gRPC API для управления туннелями
- [ ] Получение статуса подключенных серверов
- [ ] Создание/удаление туннелей через API
- [ ] Получение конфигураций для клиентов
- [ ] Стриминг логов в реальном времени

### 2.4 Мониторинг (pkg/monitor)
- [ ] Отслеживание активных соединений
- [ ] Health checks удаленных серверов
- [ ] Метрики производительности
- [ ] Уведомления об отключениях

## Этап 3: Разработка клиента

### 3.1 Tunnel Client (cmd/tunnel-client)
- [ ] SSH клиент с reverse tunnel
- [ ] Автоматическое переподключение при обрывах
- [ ] Конфигурация через файл/переменные окружения
- [ ] Регистрация на сервере с уникальным ID
- [ ] Heartbeat для поддержания соединения

### 3.2 Система конфигурации (pkg/config)
- [ ] Загрузка конфигурации из файла/ENV
- [ ] Автоматическое получение конфига с сервера
- [ ] Валидация параметров подключения
- [ ] Горячая перезагрузка конфигурации

### 3.3 Автозапуск и сервисы
- [ ] Systemd service файлы для Linux
- [ ] Windows Service для Windows серверов
- [ ] Docker контейнер для клиента
- [ ] Скрипты установки

## Этап 4: CLI инструменты управления

### 4.1 CLI клиент для управления (cmd/tunnel-cli)
- [ ] Команды для просмотра статуса серверов
- [ ] Управление туннелями через командную строку
- [ ] Просмотр логов подключений
- [ ] Команды для добавления/удаления клиентов

## Этап 5: Безопасность и надежность

### 5.1 Безопасность
- [ ] TLS шифрование для всех соединений
- [ ] Ротация SSH ключей
- [ ] Rate limiting для API
- [ ] Fail2ban интеграция для защиты от брутфорса
- [ ] Аудит логи

### 5.2 Надежность
- [ ] Graceful shutdown для всех сервисов
- [ ] Автоматический restart при падениях
- [ ] Backup конфигураций
- [ ] Load balancing (если нужно несколько мостов)

## Этап 6: Деплой и автоматизация

### 6.1 Docker контейнеры (deploy/)
- [ ] Dockerfile для tunnel-server
- [ ] Dockerfile для tunnel-client  
- [ ] Docker Compose для полного стека
- [ ] Multi-arch образы (amd64, arm64)

### 6.2 CI/CD (GitHub Actions)
- [ ] Автоматическая сборка при push
- [ ] Тестирование кода
- [ ] Создание релизов с бинарными файлами
- [ ] Автодеплой на сервер

### 6.3 Мониторинг продакшена
- [ ] Prometheus метрики
- [ ] Grafana дашборды
- [ ] Alertmanager уведомления
- [ ] Логирование в ELK/Loki

## Этап 7: Документация и тестирование

### 7.1 Документация (docs/)
- [ ] Инструкция по установке сервера
- [ ] Инструкция по подключению клиентов
- [ ] API документация
- [ ] Troubleshooting guide
- [ ] Примеры использования

### 7.2 Тестирование
- [ ] Unit тесты для всех компонентов
- [ ] Integration тесты туннелирования
- [ ] Load тесты производительности
- [ ] Тесты на отказоустойчивость

## Примерная последовательность разработки

1. **Week 1-2:** Создание базовой структуры + простой SSH tunnel server
2. **Week 3-4:** Разработка tunnel-client с автопереподключением  
3. **Week 5-6:** gRPC API сервер + система мониторинга
4. **Week 7-8:** CLI клиент для управления
5. **Week 9-10:** Безопасность + Docker контейнеры
6. **Week 11-12:** Тестирование + документация + деплой

## Технические детали для реализации

### Основные Go библиотеки:
- `golang.org/x/crypto/ssh` - SSH клиент/сервер
- `google.golang.org/grpc` - gRPC для API
- `github.com/spf13/cobra` - CLI интерфейс
- `github.com/spf13/viper` - конфигурация
- `github.com/sirupsen/logrus` - логирование

### Конфигурации:
- **Server config:** порты, домены, SSL сертификаты, авторизация
- **Client config:** server endpoint, SSH ключи, локальные сервисы для проброса

### Протокол взаимодействия:
1. Клиент подключается к серверу по SSH
2. Сервер создает reverse tunnel на динамическом порту
3. Сервер регистрирует клиента в своей базе
4. Доступ к клиенту через `tunnel.yourdomain.com:assigned-port`

## Прогресс выполнения

### Завершено:
- [x] Создание структуры проекта
- [x] Базовые файлы конфигурации
- [x] README и план разработки

### Текущий этап: Этап 2.1 - SSH Tunnel Server
Следующие шаги:
1. Реализация базового SSH сервера
2. Добавление reverse tunnel функциональности
3. Система регистрации клиентов
